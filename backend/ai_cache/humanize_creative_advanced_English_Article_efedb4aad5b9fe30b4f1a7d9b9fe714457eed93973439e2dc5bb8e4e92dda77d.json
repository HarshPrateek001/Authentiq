{"response": "# When the Server Crashed: A Narrative Walk\u2011through of Authentiq\u2019s Debug Log  \n\n*By\u202f[Your Name] \u2013\u202fTech\u2011Diary, February\u202f2026*  \n\n---  \n\n## 1. Prologue \u2013\u202fWhat the Log Is Trying to Tell Us  \n\nAt first glance the output looks like a string of indifferent timestamps, HTTP verbs, and cryptic error codes. In reality it is the pulse of a live FastAPI/Uvicorn server, a heartbeat that suddenly flatlines, hiccups, and then tries\u2014sometimes vainly\u2014to revive itself.  \n\nIn this article we\u2019ll translate that raw console chatter into a readable story, spotlight the moments where things went sideways, and extract the lessons any SaaS developer can carry forward.  \n\n---  \n\n## 2. The Calm Before the Storm  \n\n```\nINFO: 127.0.0.1:49159 - \"POST /api/auth/login HTTP/1.1\" 200 OK\nINFO: Shutting down\nINFO: Waiting for application shutdown.\nINFO: Application shutdown complete.\nINFO: Finished server process [3112]\n```\n\nA user logs in successfully (`200 OK`). The server receives a graceful shutdown command, waits for all coroutines to finish, and exits cleanly. Nothing alarming yet\u2014just the routine lifecycle of a development server that reloads on file changes.  \n\n---  \n\n## 3. First Glitch \u2013\u202fThe Watcher Strikes  \n\n```\nWARNING: WatchFiles detected changes in 'main.py'. Reloading...\nProcess SpawnProcess-4:\nTraceback (most recent call last):\n  \u2026\n  sys.stdin = os.fdopen(stdin_fileno)\nKeyboardInterrupt\n```\n\nThe *WatchFiles* utility detects a modification in `main.py` and triggers a hot\u2011reload. The child process that Uvicorn spawns to handle the new code receives a `KeyboardInterrupt` while trying to re\u2011wire its standard input.  \n\n**Why it matters:** A hot\u2011reload is convenient, but in a multiprocessing environment it can leave orphaned workers hanging, especially on Windows where the `multiprocessing` spawn method is more fragile.  \n\n---  \n\n## 4. The Server Springs Back \u2013\u202fA New Session Begins  \n\n```\nINFO: Started server process [19908]\nINFO: Waiting for application startup.\nINFO: Application startup complete.\nINFO: 127.0.0.1:49163 - \"POST /api/check-plagiarism HTTP/1.1\" 200 OK\nINFO: 127.0.0.1:56216 - \"OPTIONS /api/user/me HTTP/1.1\" 200 OK\n```\n\nA fresh process (PID\u202f19908) boots up, the FastAPI app registers its routes, and the first request to the *plagiarism* endpoint succeeds. So far, the restart appears successful.  \n\n---  \n\n## 5. The First Warning \u2013\u202fDNS Resolution Fails  \n\n```\nAuth Error: [Errno 11002] getaddrinfo failed\nUser Fetch Error:\nINFO: 127.0.0.1:56216 - \"GET /api/user/me HTTP/1.1\" 401 Unauthorized\n```\n\nEvery time the client attempts to fetch the current user (`/api/user/me`), the backend throws a `getaddrinfo` error. This is a low\u2011level DNS resolution failure, typically indicating that the host name of an external authentication service (perhaps Supabase or another identity provider) cannot be resolved.  \n\nBecause the request cannot be authenticated, the endpoint returns **401\u202fUnauthorized**.  \n\n---  \n\n## 6. Cascading Failures \u2013\u202fUnbound Local Variables  \n\n```\nCRITICAL ERROR in humanize_text_endpoint: cannot access local variable 'user' where it is not associated with a value\nINFO: 127.0.0.1:58704 - \"POST /api/humanizer HTTP/1.1\" 500 Internal Server Error\n```\n\nThe humanizer route attempts to reference a `user` object that was never populated (the earlier auth request failed). Python raises an `UnboundLocalError`, which Uvicorn translates into a **500\u202fInternal Server Error**.  \n\nA similar pattern repeats for the plagiarism check:  \n\n```\nCRITICAL ERROR in check_plagiarism_endpoint: cannot access local variable 'user' \u2026\nINFO: 127.0.0.1:55074 - \"POST /api/check-plagiarism HTTP/1.1\" 500 Internal Server Error\n```\n\n**Takeaway:** When authentication is a prerequisite for downstream logic, guard every dependent block with an early return or exception handling that clearly distinguishes \u201cno user\u201d from \u201cinternal bug\u201d.  \n\n---  \n\n## 7. The Reload Loop \u2013\u202fMore Hot\u2011Reloads, More Interrupts  \n\nThe file watcher detects yet another change in `main.py`, prompting another reload. The same `KeyboardInterrupt` pattern resurfaces, confirming that the development environment\u2019s auto\u2011reload is colliding with the multiprocessing model.  \n\n---  \n\n## 8. Diving Deeper \u2013\u202fSupabase Foreign\u2011Key Nightmares  \n\nAfter the server stabilises for a moment, a login succeeds:\n\n```\nINFO: 127.0.0.1:58858 - \"POST /api/auth/login HTTP/1.1\" 200 OK\n```\n\nImmediately the backend tries to persist a new **document**, a **check**, and a **humanize request** to Supabase. All three attempts fail with identical foreign\u2011key violations:\n\n```\nError inserting document: \u2026 violates foreign key constraint \"documents_user_id_fkey\"\nKey (user_id)=(48428cc6-\u2026\u2011db46ec) is not present in table \"profiles\".\n```\n\nIn plain English: the `user_id` extracted from the JWT does not exist in the `profiles` table. The database refuses to create rows that reference a non\u2011existent parent record.  \n\n**Root causes may include:**  \n\n1. **Delayed user provisioning** \u2013 the authentication service issues a token before the profile row is inserted.  \n2. **Mismatched UUID generation** \u2013 the client and server use different UUID versions or namespaces.  \n3. **Stale token** \u2013 the token belongs to a user that was deleted or never created in Supabase.  \n\n---  \n\n## 9. The Final Blow \u2013\u202fExpired JWT  \n\nLater in the session we encounter a different authentication error:\n\n```\nAuth Error: invalid JWT: token is expired\nUser Fetch Error:\nINFO: 127.0.0.1:61726 - \"GET /api/user/me HTTP/1.1\" 401 Unauthorized\n```\n\nNow the token is syntactically valid but its `exp` claim has passed. The endpoint again returns **401**, and the downstream routes (plagiarism check, humanizer) continue to respond with **200\u202fOK** because the client retries without the expired token, but the server still logs the auth failure.  \n\n---  \n\n## 10. Summary of the Failure Timeline  \n\n| Phase | Event | Consequence |\n|------|-------|-------------|\n| **Startup** | Normal login (`200 OK`) | Baseline success |\n| **Reload #1** | File change \u2192 hot\u2011reload \u2192 `KeyboardInterrupt` | Worker termination |\n| **Auth Calls** | DNS lookup fails (`getaddrinfo`) | 401 responses, missing `user` |\n| **Endpoint Logic** | Unbound `user` variable | 500 errors in humanizer & plagiarism |\n| **Reload #2** | Same hot\u2011reload issue repeats | Repeated process interruptions |\n| **Database Writes** | Foreign\u2011key violations on `documents`, `checks`, `humanize_requests` | No persistence, silent data loss |\n| **Auth Token** | Expired JWT | Further 401s, client must re\u2011login |\n\n---  \n\n## 11. Lessons Learned \u2013\u202fFrom Log to Action Plan  \n\n1. **Rethink Hot\u2011Reload in Multiprocessing**  \n   - Use `--reload` only with a single\u2011process server (e.g., `uvicorn main:app --reload`).  \n   - For Windows, consider `uvicorn.run(..., workers=1)` during development or switch to `watchgod`\u2011based reloaders that play nicer with `multiprocessing`.  \n\n2. **Separate DNS Resolution from Business Logic**  \n   - Cache the authentication service\u2019s endpoint or inject a pre\u2011resolved IP via environment variables.  \n   - Add retry logic with exponential back\u2011off to survive transient DNS glitches.  \n\n3. **Guard Against Unauthenticated Access**  \n   - Decorate routes with `@router.get(..., dependencies=[Depends(get_current_user)])`.  \n   - Inside the endpoint, verify `user` is not `None` before any further processing.  \n\n4. **Synchronise User Creation Across Services**  \n   - Implement a **post\u2011login hook** that guarantees a profile row exists before issuing a token.  \n   - Use database triggers or an event\u2011driven pipeline (e.g.,", "timestamp": "2026-02-28T23:20:00.776574"}